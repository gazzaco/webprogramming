<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>초보자용 테트리스 (간단 버전)</title>
  <style>
    /* 간단한 스타일: 화면 가운데 캔버스 배치 */
    body { display:flex; align-items:center; justify-content:center; height:100vh; margin:0; font-family:Arial, Helvetica, sans-serif; background:#111; color:#eee }
    .wrap { display:flex; gap:20px; align-items:flex-start }
    canvas { background:#0b0b0b; image-rendering:pixelated; border:4px solid #222; }
    .ui { width:200px }
    .ui h1{ font-size:18px; margin:0 0 8px }
    .ui p{ margin:6px 0 }
    .button { display:inline-block; margin-top:8px; padding:6px 10px; background:#222; border-radius:6px; cursor:pointer }
    .row { display:flex; justify-content:space-between }
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="board" width="200" height="400"></canvas>
    <div class="ui">
      <h1>초보자용 테트리스</h1>
      <p>설명: 이 파일은 학습용으로 간단하게 만든 테트리스입니다.</p>
      <div class="row"><div>점수</div><div id="score">0</div></div>
      <div class="row"><div>레벨</div><div id="level">1</div></div>
      <p>조작키:</p>
      <ul>
        <li>← → : 좌우 이동</li>
        <li>↑ : 회전</li>
        <li>↓ : 빠르게 내려오기</li>
        <li>스페이스 : 즉시 떨어뜨리기</li>
      </ul>
      <div class="button" id="startBtn">게임 시작 / 재시작</div>
      <p style="margin-top:12px;font-size:13px;color:#bbb">구현된 기능: 조각 생성, 이동, 충돌, 회전, 한 줄 지우기, 점수, 레벨업, 게임오버</p>
      <p style="font-size:12px;color:#999">원리 학습용으로 코드를 읽으며 수정해보세요.</p>
    </div>
  </div>

  <script>
  // ----------------------------
  // 초보자용 간단 테트리스 구현 (한 파일)
  // 주요 개념에 주석을 달아 이해를 도와줍니다.
  // ----------------------------

  const COLS = 10;           // 가로 칸 개수
  const ROWS = 20;           // 세로 칸 개수
  const BLOCK = 20;          // 블록 한 칸의 픽셀 크기 (CSS에서 캔버스 크기와 일치)

  const canvas = document.getElementById('board');
  const ctx = canvas.getContext('2d');
  // 캔버스의 내부 픽셀 크기를 블록 단위로 맞춘다
  canvas.width = COLS * BLOCK;
  canvas.height = ROWS * BLOCK;

  // 보드 배열: 0은 빈칸, 양수는 블록 색상 인덱스
  let board = createMatrix(COLS, ROWS);

  // 테트리스 조각 모양들 (4x4 매트릭스로 표현) - 회전은 행/열 변환으로 처리
  const PIECES = [
    // I
    { shape: [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]], color: '#00f0f0' },
    // J
    { shape: [[2,0,0],[2,2,2],[0,0,0]], color: '#0000f0' },
    // L
    { shape: [[0,0,3],[3,3,3],[0,0,0]], color: '#f0a000' },
    // O
    { shape: [[4,4],[4,4]], color: '#f0f000' },
    // S
    { shape: [[0,5,5],[5,5,0],[0,0,0]], color: '#00f000' },
    // T
    { shape: [[0,6,0],[6,6,6],[0,0,0]], color: '#a000f0' },
    // Z
    { shape: [[7,7,0],[0,7,7],[0,0,0]], color: '#f00000' }
  ];

  // 현재 떨어지는 조각 상태
  let piece = null;
  let pieceX = 0;
  let pieceY = 0;

  // 게임 상태
  let dropInterval = 1000; // 기본 내려오는 속도(ms)
  let dropTimer = null;
  let score = 0;
  let level = 1;
  let gameOver = false;

  document.getElementById('startBtn').addEventListener('click', startGame);

  // 키 입력 처리
  document.addEventListener('keydown', (e) => {
    if (!piece || gameOver) return;
    if (e.code === 'ArrowLeft') move(-1);
    else if (e.code === 'ArrowRight') move(1);
    else if (e.code === 'ArrowDown') drop();
    else if (e.code === 'ArrowUp') rotatePiece();
    else if (e.code === 'Space') hardDrop();
    render();
  });

  // ------------------ 유틸리티 함수 ------------------
  function createMatrix(w, h) {
    const m = [];
    for (let y = 0; y < h; y++) {
      m.push(new Array(w).fill(0));
    }
    return m;
  }

  function cloneShape(shape) {
    return shape.map(row => row.slice());
  }

  function randomPiece() {
    const idx = Math.floor(Math.random() * PIECES.length);
    return { shape: cloneShape(PIECES[idx].shape), color: PIECES[idx].color };
  }

  // 충돌 검사: 조각이 보드 범위를 벗어나거나 채워진 칸과 겹치면 true
  function collide(board, piece, x, y) {
    for (let py = 0; py < piece.shape.length; py++) {
      for (let px = 0; px < piece.shape[py].length; px++) {
        if (piece.shape[py][px]) {
          const bx = x + px;
          const by = y + py;
          if (bx < 0 || bx >= COLS || by >= ROWS) return true;
          if (by >= 0 && board[by][bx]) return true;
        }
      }
    }
    return false;
  }

  // 조각을 보드에 고정시키기
  function merge(board, piece, x, y) {
    for (let py = 0; py < piece.shape.length; py++) {
      for (let px = 0; px < piece.shape[py].length; px++) {
        if (piece.shape[py][px]) {
          const bx = x + px;
          const by = y + py;
          if (by >= 0 && by < ROWS && bx >= 0 && bx < COLS) {
            board[by][bx] = piece.shape[py][px];
          }
        }
      }
    }
  }

  // 한 줄 지우기 및 점수 처리
  function clearLines() {
    let lines = 0;
    outer: for (let y = ROWS - 1; y >= 0; y--) {
      for (let x = 0; x < COLS; x++) {
        if (!board[y][x]) {
          continue outer;
        }
      }
      // 해당 줄이 가득 찼으면 제거
      const row = board.splice(y, 1)[0];
      board.unshift(new Array(COLS).fill(0));
      lines++;
      y++; // 같은 인덱스를 다시 검사
    }
    if (lines > 0) {
      // 간단 점수: 1줄=100, 2줄=300, 3줄=500, 4줄=800
      const points = [0,100,300,500,800];
      score += points[lines];
      document.getElementById('score').textContent = score;
      // 레벨업: 예시로 1000점마다 레벨 증가
      const newLevel = Math.floor(score / 1000) + 1;
      if (newLevel !== level) {
        level = newLevel;
        document.getElementById('level').textContent = level;
        // 속도 빠르게
        dropInterval = Math.max(100, 1000 - (level-1)*100);
        resetDropTimer();
      }
    }
  }

  // 조각 회전 (시계 방향). 충돌 시 벽킥 간단 구현: 좌/우로 밀어본다.
  function rotatePiece() {
    // 정사각형 행렬이 아닐 수 있으므로 새로운 행렬을 만든다
    const s = piece.shape;
    const H = s.length, W = s[0].length;
    const rotated = Array.from({length: W}, () => new Array(H).fill(0));
    for (let y = 0; y < H; y++) {
      for (let x = 0; x < W; x++) {
        rotated[x][H-1-y] = s[y][x];
      }
    }
    const oldShape = piece.shape;
    piece.shape = rotated;
    // 간단 벽킥: 왼쪽/오른쪽으로 최대 2칸 이동해본다
    for (let i = 0; i < 3; i++) {
      const dx = [0, -1, 1][i];
      if (!collide(board, piece, pieceX + dx, pieceY)) return;
    }
    // 회전 불가하면 원래대로
    piece.shape = oldShape;
  }

  // 좌우 이동
  function move(dir) {
    if (!collide(board, piece, pieceX + dir, pieceY)) {
      pieceX += dir;
    }
  }

  // 한 칸 아래로 이동 (일반 낙하)
  function drop() {
    if (!collide(board, piece, pieceX, pieceY + 1)) {
      pieceY++;
    } else {
      // 충돌하면 고정
      merge(board, piece, pieceX, pieceY);
      clearLines();
      spawnPiece();
    }
  }

  // 즉시 떨어뜨리기
  function hardDrop() {
    while(!collide(board, piece, pieceX, pieceY + 1)) pieceY++;
    merge(board, piece, pieceX, pieceY);
    clearLines();
    spawnPiece();
    render();
  }

  // 새로운 조각 생성
  function spawnPiece() {
    piece = randomPiece();
    pieceX = Math.floor((COLS - piece.shape[0].length) / 2);
    pieceY = - (piece.shape.length); // 위쪽 바깥에서 시작
    // 즉시 충돌하면 게임오버
    if (collide(board, piece, pieceX, pieceY + 1)) {
      gameOver = true;
      stopDropTimer();
      alert('게임 오버! 점수: ' + score);
    }
  }

  // 렌더링 함수: 보드와 현재 조각 그리기
  function render() {
    ctx.clearRect(0,0,canvas.width,canvas.height);
    // 그리드 선 (선택 사항)
    // draw board blocks
    for (let y = 0; y < ROWS; y++) {
      for (let x = 0; x < COLS; x++) {
        if (board[y][x]) drawBlock(x, y, getColor(board[y][x]));
      }
    }
    // 현재 조각
    if (piece) {
      for (let py = 0; py < piece.shape.length; py++) {
        for (let px = 0; px < piece.shape[py].length; px++) {
          if (piece.shape[py][px]) {
            const bx = pieceX + px;
            const by = pieceY + py;
            if (by >= 0) drawBlock(bx, by, piece.color);
          }
        }
      }
    }
  }

  function drawBlock(x,y,color) {
    ctx.fillStyle = color;
    ctx.fillRect(x*BLOCK, y*BLOCK, BLOCK-1, BLOCK-1);
    // 간단한 테두리 효과
    ctx.strokeStyle = '#000';
    ctx.strokeRect(x*BLOCK, y*BLOCK, BLOCK-1, BLOCK-1);
  }

  // shape에 저장된 숫자 -> 색으로 변환 (간단히 값에 따른 기본 색 사용)
  function getColor(val) {
    // 매핑은 PIECES 순서와 일치하도록 설계
    const map = [null,'#00f0f0','#0000f0','#f0a000','#f0f000','#00f000','#a000f0','#f00000'];
    return map[val] || '#888';
  }

  // 게임 루프를 위한 타이머 관리
  function resetDropTimer() {
    stopDropTimer();
    dropTimer = setInterval(() => {
      if (!gameOver && piece) {
        drop(); render();
      }
    }, dropInterval);
  }
  function stopDropTimer() { if (dropTimer) clearInterval(dropTimer); dropTimer = null; }

  // 게임 시작/재시작
  function startGame() {
    board = createMatrix(COLS, ROWS);
    score = 0; level = 1; gameOver = false;
    document.getElementById('score').textContent = score;
    document.getElementById('level').textContent = level;
    dropInterval = 1000;
    spawnPiece();
    resetDropTimer();
    render();
  }

  // 페이지 로드 시 초기 렌더 (빈 보드)
  render();
  </script>
</body>
</html>
