<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>초보자용 테트리스 (다음 블록 표시)</title>
  <style>
    body { display:flex; align-items:center; justify-content:center; height:100vh; margin:0; font-family:Arial, Helvetica, sans-serif; background:#111; color:#eee }
    .wrap { display:flex; gap:20px; align-items:flex-start }
    canvas { background:#0b0b0b; image-rendering:pixelated; border:4px solid #222; }
    /* ✅ 격자무늬 추가 */
    canvas {
      background-color: #0b0b0b;
      background-image:
        linear-gradient(#222 1px, transparent 1px),
        linear-gradient(90deg, #222 1px, transparent 1px);
      background-size: 20px 20px;
      border: 4px solid #333;
    }
    #next {
      width: 100px;
      height: 100px;
      background:#0b0b0b;
      border:4px solid #333;
      background-image:
        linear-gradient(#222 1px, transparent 1px),
        linear-gradient(90deg, #222 1px, transparent 1px);
      background-size: 20px 20px;
    }
    .ui { width:200px }
    .ui h1{ font-size:18px; margin:0 0 8px }
    .ui p{ margin:6px 0 }
    .button { display:inline-block; margin-top:8px; padding:6px 10px; background:#222; border-radius:6px; cursor:pointer }
    .row { display:flex; justify-content:space-between }
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="board" width="200" height="400"></canvas>
    <div class="ui">
      <h1>초보자용 테트리스</h1>
      <p>설명: 이 파일은 학습용으로 간단하게 만든 테트리스입니다.</p>
      <div class="row"><div>점수</div><div id="score">0</div></div>
      <div class="row"><div>레벨</div><div id="level">1</div></div>

      <!-- ✅ 다음 블록 표시 부분 -->
      <h2 style="font-size:16px;margin-top:10px;">다음 블록</h2>
      <canvas id="next" width="100" height="100"></canvas>

      <p>조작키:</p>
      <ul>
        <li>← → : 좌우 이동</li>
        <li>↑ : 회전</li>
        <li>↓ : 빠르게 내려오기</li>
        <li>스페이스 : 즉시 떨어뜨리기</li>
      </ul>
      <div class="button" id="startBtn">게임 시작 / 재시작</div>
      <p style="margin-top:12px;font-size:13px;color:#bbb">구현된 기능: 조각 생성, 이동, 충돌, 회전, 한 줄 지우기, 점수, 레벨업, 다음 블록 표시, 게임오버</p>
    </div>
  </div>

  <script>
  const COLS = 10;
  const ROWS = 20;
  const BLOCK = 20;

  const canvas = document.getElementById('board');
  const ctx = canvas.getContext('2d');
  canvas.width = COLS * BLOCK;
  canvas.height = ROWS * BLOCK;

  const nextCanvas = document.getElementById('next');
  const nextCtx = nextCanvas.getContext('2d');

  let board = createMatrix(COLS, ROWS);

  const PIECES = [
    { shape: [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]], color: '#00f0f0' },
    { shape: [[2,0,0],[2,2,2],[0,0,0]], color: '#0000f0' },
    { shape: [[0,0,3],[3,3,3],[0,0,0]], color: '#f0a000' },
    { shape: [[4,4],[4,4]], color: '#f0f000' },
    { shape: [[0,5,5],[5,5,0],[0,0,0]], color: '#00f000' },
    { shape: [[0,6,0],[6,6,6],[0,0,0]], color: '#a000f0' },
    { shape: [[7,7,0],[0,7,7],[0,0,0]], color: '#f00000' }
  ];

  let piece = null;
  let pieceX = 0;
  let pieceY = 0;
  let nextPiece = null; // ✅ 다음 블록 저장용

  let dropInterval = 1000;
  let dropTimer = null;
  let score = 0;
  let level = 1;
  let gameOver = false;

  document.getElementById('startBtn').addEventListener('click', startGame);
  document.addEventListener('keydown', e => {
    if (!piece || gameOver) return;
    if (e.code === 'ArrowLeft') move(-1);
    else if (e.code === 'ArrowRight') move(1);
    else if (e.code === 'ArrowDown') drop();
    else if (e.code === 'ArrowUp') rotatePiece();
    else if (e.code === 'Space') hardDrop();
    render();
  });

  function createMatrix(w, h) {
    const m = [];
    for (let y = 0; y < h; y++) m.push(new Array(w).fill(0));
    return m;
  }
  function cloneShape(shape) { return shape.map(row => row.slice()); }
  function randomPiece() {
    const idx = Math.floor(Math.random() * PIECES.length);
    return { shape: cloneShape(PIECES[idx].shape), color: PIECES[idx].color };
  }

  function collide(board, piece, x, y) {
    for (let py = 0; py < piece.shape.length; py++) {
      for (let px = 0; px < piece.shape[py].length; px++) {
        if (piece.shape[py][px]) {
          const bx = x + px;
          const by = y + py;
          if (bx < 0 || bx >= COLS || by >= ROWS) return true;
          if (by >= 0 && board[by][bx]) return true;
        }
      }
    }
    return false;
  }

  function merge(board, piece, x, y) {
    for (let py = 0; py < piece.shape.length; py++) {
      for (let px = 0; px < piece.shape[py].length; px++) {
        if (piece.shape[py][px]) {
          const bx = x + px;
          const by = y + py;
          if (by >= 0 && by < ROWS && bx >= 0 && bx < COLS) {
            board[by][bx] = piece.shape[py][px];
          }
        }
      }
    }
  }

  function clearLines() {
    let lines = 0;
    outer: for (let y = ROWS - 1; y >= 0; y--) {
      for (let x = 0; x < COLS; x++) {
        if (!board[y][x]) continue outer;
      }
      board.splice(y, 1);
      board.unshift(new Array(COLS).fill(0));
      lines++;
      y++;
    }
    if (lines > 0) {
      const points = [0,100,300,500,800];
      score += points[lines];
      document.getElementById('score').textContent = score;
      const newLevel = Math.floor(score / 1000) + 1;
      if (newLevel !== level) {
        level = newLevel;
        document.getElementById('level').textContent = level;
        dropInterval = Math.max(100, 1000 - (level-1)*100);
        resetDropTimer();
      }
    }
  }

  function rotatePiece() {
    const s = piece.shape;
    const H = s.length, W = s[0].length;
    const rotated = Array.from({length: W}, () => new Array(H).fill(0));
    for (let y = 0; y < H; y++) for (let x = 0; x < W; x++) rotated[x][H-1-y] = s[y][x];
    const oldShape = piece.shape;
    piece.shape = rotated;
    for (let i = 0; i < 3; i++) {
      const dx = [0, -1, 1][i];
      if (!collide(board, piece, pieceX + dx, pieceY)) return;
    }
    piece.shape = oldShape;
  }

  function move(dir) { if (!collide(board, piece, pieceX + dir, pieceY)) pieceX += dir; }
  function drop() {
    if (!collide(board, piece, pieceX, pieceY + 1)) pieceY++;
    else { merge(board, piece, pieceX, pieceY); clearLines(); spawnPiece(); }
  }
  function hardDrop() {
    while(!collide(board, piece, pieceX, pieceY + 1)) pieceY++;
    merge(board, piece, pieceX, pieceY);
    clearLines();
    spawnPiece();
    render();
  }

  // ✅ 다음 블록 표시 포함
  function spawnPiece() {
    if (!nextPiece) nextPiece = randomPiece();
    piece = nextPiece;
    nextPiece = randomPiece();
    renderNext();

    pieceX = Math.floor((COLS - piece.shape[0].length) / 2);
    pieceY = - (piece.shape.length);
    if (collide(board, piece, pieceX, pieceY + 1)) {
      gameOver = true;
      stopDropTimer();
      alert('게임 오버! 점수: ' + score);
    }
  }

  function renderNext() {
    nextCtx.clearRect(0, 0, nextCanvas.width, nextCanvas.height);
    const shape = nextPiece.shape;
    const color = nextPiece.color;
    const offsetX = 2;
    const offsetY = 2;
    for (let y = 0; y < shape.length; y++) {
      for (let x = 0; x < shape[y].length; x++) {
        if (shape[y][x]) {
          drawNextBlock(x + offsetX, y + offsetY, color);
        }
      }
    }
  }

  function drawNextBlock(x, y, color) {
    nextCtx.fillStyle = color;
    nextCtx.fillRect(x*BLOCK/2, y*BLOCK/2, BLOCK/2 - 1, BLOCK/2 - 1);
    nextCtx.strokeStyle = "#000";
    nextCtx.strokeRect(x*BLOCK/2, y*BLOCK/2, BLOCK/2 - 1, BLOCK/2 - 1);
  }

  function render() {
    ctx.clearRect(0,0,canvas.width,canvas.height);
    for (let y = 0; y < ROWS; y++)
      for (let x = 0; x < COLS; x++)
        if (board[y][x]) drawBlock(x, y, getColor(board[y][x]));
    if (piece) {
      for (let py = 0; py < piece.shape.length; py++) {
        for (let px = 0; px < piece.shape[py].length; px++) {
          if (piece.shape[py][px]) {
            const bx = pieceX + px;
            const by = pieceY + py;
            if (by >= 0) drawBlock(bx, by, piece.color);
          }
        }
      }
    }
  }

  function drawBlock(x,y,color) {
    ctx.fillStyle = color;
    ctx.fillRect(x*BLOCK, y*BLOCK, BLOCK-1, BLOCK-1);
    ctx.strokeStyle = '#000';
    ctx.strokeRect(x*BLOCK, y*BLOCK, BLOCK-1, BLOCK-1);
  }

  function getColor(val) {
    const map = [null,'#00f0f0','#0000f0','#f0a000','#f0f000','#00f000','#a000f0','#f00000'];
    return map[val] || '#888';
  }

  function resetDropTimer() {
    stopDropTimer();
    dropTimer = setInterval(() => {
      if (!gameOver && piece) { drop(); render(); }
    }, dropInterval);
  }
  function stopDropTimer() { if (dropTimer) clearInterval(dropTimer); dropTimer = null; }

  function startGame() {
    board = createMatrix(COLS, ROWS);
    score = 0; level = 1; gameOver = false;
    document.getElementById('score').textContent = score;
    document.getElementById('level').textContent = level;
    dropInterval = 1000;
    nextPiece = null;
    spawnPiece();
    resetDropTimer();
    render();
  }

  render();
  </script>
</body>
</html>
