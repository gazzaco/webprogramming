<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>초보자용 테트리스 (홀드 + 격자무늬)</title>
  <style>
    body {
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100vh;
      margin: 0;
      font-family: Arial, Helvetica, sans-serif;
      background: #111;
      color: #eee;
    }
    .wrap { display: flex; gap: 20px; align-items: flex-start; }
    canvas {
      background-color: #0b0b0b;
      background-image:
        linear-gradient(#222 1px, transparent 1px),
        linear-gradient(90deg, #222 1px, transparent 1px);
      background-size: 20px 20px; /* 블록 크기(BLOCK) 기준 */
      border: 4px solid #333;
      image-rendering: pixelated;
    }
    .ui { width: 200px }
    .ui h1 { font-size: 18px; margin: 0 0 8px }
    .ui h2 { font-size: 16px; margin: 10px 0 5px }
    .ui p { margin: 6px 0 }
    .button {
      display: inline-block;
      margin-top: 8px;
      padding: 6px 10px;
      background: #222;
      border-radius: 6px;
      cursor: pointer;
    }
    .row { display: flex; justify-content: space-between }
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="board" width="200" height="400"></canvas>
    <div class="ui">
      <h1>초보자용 테트리스</h1>
      <p>설명: 이 파일은 학습용으로 간단하게 만든 테트리스입니다.</p>

      <!-- ✅ HOLD 영역 -->
      <h2>HOLD</h2>
      <canvas id="holdCanvas" width="80" height="80"></canvas>

      <!-- ✅ NEXT 영역 -->
      <h2>NEXT</h2>
      <canvas id="nextCanvas" width="80" height="80"></canvas>

      <div class="row"><div>점수</div><div id="score">0</div></div>
      <div class="row"><div>레벨</div><div id="level">1</div></div>

      <p>조작키:</p>
      <ul>
        <li>← → : 좌우 이동</li>
        <li>↑ : 회전</li>
        <li>↓ : 빠르게 내려오기</li>
        <li>스페이스 : 즉시 떨어뜨리기</li>
        <li>Z : 블록 홀드</li>
      </ul>

      <div class="button" id="startBtn">게임 시작 / 재시작</div>
    </div>
  </div>

  <script>
  const COLS = 10, ROWS = 20, BLOCK = 20;

  const canvas = document.getElementById('board');
  const ctx = canvas.getContext('2d');
  canvas.width = COLS * BLOCK;
  canvas.height = ROWS * BLOCK;

  const nextCanvas = document.getElementById('nextCanvas');
  const nctx = nextCanvas.getContext('2d');

  const holdCanvas = document.getElementById('holdCanvas');
  const hctx = holdCanvas.getContext('2d');

  const PIECES = [
    { shape: [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]], color: '#00f0f0' },
    { shape: [[2,0,0],[2,2,2],[0,0,0]], color: '#0000f0' },
    { shape: [[0,0,3],[3,3,3],[0,0,0]], color: '#f0a000' },
    { shape: [[4,4],[4,4]], color: '#f0f000' },
    { shape: [[0,5,5],[5,5,0],[0,0,0]], color: '#00f000' },
    { shape: [[0,6,0],[6,6,6],[0,0,0]], color: '#a000f0' },
    { shape: [[7,7,0],[0,7,7],[0,0,0]], color: '#f00000' }
  ];

  let board = createMatrix(COLS, ROWS);
  let piece = null, nextPiece = null, holdPiece = null;
  let pieceX = 0, pieceY = 0;
  let canHold = true;
  let dropInterval = 1000, dropTimer = null;
  let score = 0, level = 1, gameOver = false;

  document.getElementById('startBtn').addEventListener('click', startGame);

  document.addEventListener('keydown', (e) => {
    if (!piece || gameOver) return;
    if (e.code === 'ArrowLeft') move(-1);
    else if (e.code === 'ArrowRight') move(1);
    else if (e.code === 'ArrowDown') drop();
    else if (e.code === 'ArrowUp') rotatePiece();
    else if (e.code === 'Space') hardDrop();
    else if (e.code === 'KeyZ') holdPieceAction();
    render();
  });

  function createMatrix(w,h){return Array.from({length:h},()=>Array(w).fill(0));}
  function cloneShape(s){return s.map(r=>r.slice());}
  function randomPiece(){
    const idx=Math.floor(Math.random()*PIECES.length);
    return {shape:cloneShape(PIECES[idx].shape),color:PIECES[idx].color};
  }

  function collide(board,piece,x,y){
    for(let py=0;py<piece.shape.length;py++){
      for(let px=0;px<piece.shape[py].length;px++){
        if(piece.shape[py][px]){
          const bx=x+px,by=y+py;
          if(bx<0||bx>=COLS||by>=ROWS)return true;
          if(by>=0&&board[by][bx])return true;
        }
      }
    }return false;
  }

  function merge(board,piece,x,y){
    for(let py=0;py<piece.shape.length;py++){
      for(let px=0;px<piece.shape[py].length;px++){
        if(piece.shape[py][px]){
          const bx=x+px,by=y+py;
          if(by>=0&&by<ROWS&&bx>=0&&bx<COLS)
            board[by][bx]=piece.shape[py][px];
        }
      }
    }
  }

  function clearLines(){
    let lines=0;
    outer:for(let y=ROWS-1;y>=0;y--){
      for(let x=0;x<COLS;x++){if(!board[y][x])continue outer;}
      board.splice(y,1);
      board.unshift(Array(COLS).fill(0));
      lines++;y++;
    }
    if(lines>0){
      const points=[0,100,300,500,800];
      score+=points[lines];
      document.getElementById('score').textContent=score;
      const newLevel=Math.floor(score/1000)+1;
      if(newLevel!==level){
        level=newLevel;
        document.getElementById('level').textContent=level;
        dropInterval=Math.max(100,1000-(level-1)*100);
        resetDropTimer();
      }
    }
  }

  function rotatePiece(){
    const s=piece.shape,H=s.length,W=s[0].length;
    const r=Array.from({length:W},()=>Array(H).fill(0));
    for(let y=0;y<H;y++){for(let x=0;x<W;x++){r[x][H-1-y]=s[y][x];}}
    const old=piece.shape;
    piece.shape=r;
    for(let i=0;i<3;i++){
      const dx=[0,-1,1][i];
      if(!collide(board,piece,pieceX+dx,pieceY))return;
    }
    piece.shape=old;
  }

  function move(dir){if(!collide(board,piece,pieceX+dir,pieceY))pieceX+=dir;}
  function drop(){
    if(!collide(board,piece,pieceX,pieceY+1))pieceY++;
    else{
      merge(board,piece,pieceX,pieceY);
      clearLines();
      canHold=true;
      spawnPiece();
    }
  }

  function hardDrop(){
    while(!collide(board,piece,pieceX,pieceY+1))pieceY++;
    merge(board,piece,pieceX,pieceY);
    clearLines();canHold=true;spawnPiece();render();
  }

  function spawnPiece(){
    piece=nextPiece||randomPiece();
    nextPiece=randomPiece();
    renderNext();
    pieceX=Math.floor((COLS-piece.shape[0].length)/2);
    pieceY=-piece.shape.length;
    if(collide(board,piece,pieceX,pieceY+1)){
      gameOver=true;
      stopDropTimer();
      alert('게임 오버! 점수: '+score);
    }
  }

  function holdPieceAction(){
    if(!canHold)return;
    if(!holdPiece){
      holdPiece=piece;
      spawnPiece();
    }else{
      const temp=holdPiece;
      holdPiece=piece;
      piece=temp;
      pieceX=Math.floor((COLS-piece.shape[0].length)/2);
      pieceY=-piece.shape.length;
      if(collide(board,piece,pieceX,pieceY+1)){
        gameOver=true;stopDropTimer();alert('게임 오버! 점수: '+score);
      }
    }
    canHold=false;
    renderHold();
  }

  function drawBlock(x,y,color){
    ctx.fillStyle=color;
    ctx.fillRect(x*BLOCK,y*BLOCK,BLOCK-1,BLOCK-1);
    ctx.strokeStyle='#000';
    ctx.strokeRect(x*BLOCK,y*BLOCK,BLOCK-1,BLOCK-1);
  }

  function render(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    for(let y=0;y<ROWS;y++){
      for(let x=0;x<COLS;x++){
        if(board[y][x])drawBlock(x,y,getColor(board[y][x]));
      }
    }
    if(piece){
      for(let py=0;py<piece.shape.length;py++){
        for(let px=0;px<piece.shape[py].length;px++){
          if(piece.shape[py][px]){
            const bx=pieceX+px,by=pieceY+py;
            if(by>=0)drawBlock(bx,by,piece.color);
          }
        }
      }
    }
  }

  function renderNext(){
    nctx.clearRect(0,0,nextCanvas.width,nextCanvas.height);
    if(!nextPiece)return;
    const s=nextPiece.shape;const size=20;
    for(let y=0;y<s.length;y++){
      for(let x=0;x<s[y].length;x++){
        if(s[y][x]){
          nctx.fillStyle=nextPiece.color;
          nctx.fillRect(x*size+10,y*size+10,size-2,size-2);
          nctx.strokeStyle='#000';
          nctx.strokeRect(x*size+10,y*size+10,size-2,size-2);
        }
      }
    }
  }

  function renderHold(){
    hctx.clearRect(0,0,holdCanvas.width,holdCanvas.height);
    if(!holdPiece)return;
    const s=holdPiece.shape;const size=20;
    for(let y=0;y<s.length;y++){
      for(let x=0;x<s[y].length;x++){
        if(s[y][x]){
          hctx.fillStyle=holdPiece.color;
          hctx.fillRect(x*size+10,y*size+10,size-2,size-2);
          hctx.strokeStyle='#000';
          hctx.strokeRect(x*size+10,y*size+10,size-2,size-2);
        }
      }
    }
  }

  function getColor(v){
    const map=[null,'#00f0f0','#0000f0','#f0a000','#f0f000','#00f000','#a000f0','#f00000'];
    return map[v]||'#888';
  }

  function resetDropTimer(){
    stopDropTimer();
    dropTimer=setInterval(()=>{if(!gameOver&&piece){drop();render();}},dropInterval);
  }
  function stopDropTimer(){if(dropTimer)clearInterval(dropTimer);dropTimer=null;}

  function startGame(){
    board=createMatrix(COLS,ROWS);
    score=0;level=1;gameOver=false;
    holdPiece=null;canHold=true;
    document.getElementById('score').textContent=score;
    document.getElementById('level').textContent=level;
    dropInterval=1000;
    nextPiece=randomPiece();
    renderNext();renderHold();
    spawnPiece();
    resetDropTimer();
    render();
  }

  render();
  </script>
</body>
</html>
