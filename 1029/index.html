<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ì´ˆë³´ììš© í…ŒíŠ¸ë¦¬ìŠ¤ (í™€ë“œ + ê²©ìë¬´ëŠ¬ + ì¼ì‹œì •ì§€ + ìµœê³ ê¸°ë¡)</title>
  <style>
    body {
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100vh;
      margin: 0;
      font-family: Arial, Helvetica, sans-serif;
      background: #111;
      color: #eee;
    }
    .wrap { display: flex; gap: 20px; align-items: flex-start; }
    canvas {
      background-color: #0b0b0b;
      background-image:
        linear-gradient(#222 1px, transparent 1px),
        linear-gradient(90deg, #222 1px, transparent 1px);
      background-size: 20px 20px;
      border: 4px solid #333;
      image-rendering: pixelated;
    }
    .ui { width: 200px }
    .ui h1 { font-size: 18px; margin: 0 0 8px }
    .ui h2 { font-size: 16px; margin: 10px 0 5px }
    .ui p { margin: 6px 0 }
    .button {
      display: inline-block;
      margin-top: 8px;
      padding: 6px 10px;
      background: #222;
      border-radius: 6px;
      cursor: pointer;
      user-select: none;
    }
    .row { display: flex; justify-content: space-between }
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="board" width="200" height="400"></canvas>
    <div class="ui">
      <h1>ì´ˆë³´ììš© í…ŒíŠ¸ë¦¬ìŠ¤</h1>
      <p>ì„¤ëª…: ì´ íŒŒì¼ì€ í•™ìŠµìš©ìœ¼ë¡œ ê°„ë‹¨í•˜ê²Œ ë§Œë“  í…ŒíŠ¸ë¦¬ìŠ¤ì…ë‹ˆë‹¤.</p>

      <h2>HOLD</h2>
      <canvas id="holdCanvas" width="80" height="80"></canvas>

      <h2>NEXT</h2>
      <canvas id="nextCanvas" width="80" height="80"></canvas>

      <div class="row"><div>ì ìˆ˜</div><div id="score">0</div></div>
      <div class="row"><div>ë ˆë²¨</div><div id="level">1</div></div>

      <!-- âœ… ìµœê³ ê¸°ë¡ í‘œì‹œ -->
      <div class="row"><div>ìµœê³ ê¸°ë¡</div><div id="highScore">0</div></div>

      <!-- âœ… ìµœê³ ê¸°ë¡ ì´ˆê¸°í™” ë²„íŠ¼ ì¶”ê°€ -->
      <div class="button" id="resetHighScoreBtn">ìµœê³ ê¸°ë¡ ì´ˆê¸°í™”</div>

      <p>ì¡°ì‘í‚¤:</p>
      <ul>
        <li>â† â†’ : ì¢Œìš° ì´ë™</li>
        <li>â†‘ : íšŒì „</li>
        <li>â†“ : ë¹ ë¥´ê²Œ ë‚´ë ¤ì˜¤ê¸°</li>
        <li>ìŠ¤í˜ì´ìŠ¤ : ì¦‰ì‹œ ë–¨ì–´ëœ¨ë¦¬ê¸°</li>
        <li>Z : ë¸”ë¡ í™€ë“œ</li>
      </ul>

      <div class="button" id="startBtn">ê²Œì„ ì‹œì‘ / ì¬ì‹œì‘</div>
      <div class="button" id="pauseBtn">ì¼ì‹œì •ì§€</div>
    </div>
  </div>

  <audio id="bgm" src="tetris_bgm.mp3" loop></audio>
  <audio id="congratsSound" src="congrats.mp3"></audio>

  <script>
  const COLS = 10, ROWS = 20, BLOCK = 20;
  const canvas = document.getElementById('board');
  const ctx = canvas.getContext('2d');
  const nextCanvas = document.getElementById('nextCanvas');
  const nctx = nextCanvas.getContext('2d');
  const holdCanvas = document.getElementById('holdCanvas');
  const hctx = holdCanvas.getContext('2d');

  const PIECES = [
    { shape: [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]], color: '#00f0f0' },
    { shape: [[2,0,0],[2,2,2],[0,0,0]], color: '#0000f0' },
    { shape: [[0,0,3],[3,3,3],[0,0,0]], color: '#f0a000' },
    { shape: [[4,4],[4,4]], color: '#f0f000' },
    { shape: [[0,5,5],[5,5,0],[0,0,0]], color: '#00f000' },
    { shape: [[0,6,0],[6,6,6],[0,0,0]], color: '#a000f0' },
    { shape: [[7,7,0],[0,7,7],[0,0,0]], color: '#f00000' }
  ];

  let board = createMatrix(COLS, ROWS);
  let piece = null, nextPiece = null, holdPiece = null;
  let pieceX = 0, pieceY = 0;
  let canHold = true;
  let dropInterval = 1000, dropTimer = null;
  let score = 0, level = 1, gameOver = false;
  let isPaused = false;

  // âœ… ìµœê³ ê¸°ë¡ ë¶ˆëŸ¬ì˜¤ê¸°
  let highScore = localStorage.getItem('tetrisHighScore') ? parseInt(localStorage.getItem('tetrisHighScore')) : 0;
  document.getElementById('highScore').textContent = highScore;

  document.getElementById('startBtn').addEventListener('click', startGame);
  document.getElementById('pauseBtn').addEventListener('click', togglePause);

  // âœ… ìµœê³ ê¸°ë¡ ì´ˆê¸°í™” ë²„íŠ¼ í´ë¦­ ì‹œ
  document.getElementById('resetHighScoreBtn').addEventListener('click', () => {
    if (confirm("ì •ë§ ìµœê³ ê¸°ë¡ì„ ì´ˆê¸°í™”í•˜ì‹œê² ìŠµë‹ˆê¹Œ?")) {
      localStorage.removeItem('tetrisHighScore');
      highScore = 0;
      document.getElementById('highScore').textContent = "0";
      alert("ìµœê³ ê¸°ë¡ì´ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤.");
    }
  });

  document.addEventListener('keydown', (e) => {
    if (!piece || gameOver || isPaused) return;
    if (e.code === 'ArrowLeft') move(-1);
    else if (e.code === 'ArrowRight') move(1);
    else if (e.code === 'ArrowDown') drop();
    else if (e.code === 'ArrowUp') rotatePiece();
    else if (e.code === 'Space') hardDrop();
    else if (e.code === 'KeyZ') holdPieceAction();
    render();
  });

  function createMatrix(w,h){return Array.from({length:h},()=>Array(w).fill(0));}
  function cloneShape(s){return s.map(r=>r.slice());}
  function randomPiece(){
    const idx=Math.floor(Math.random()*PIECES.length);
    return {shape:cloneShape(PIECES[idx].shape),color:PIECES[idx].color};
  }

  function collide(board,piece,x,y){
    for(let py=0;py<piece.shape.length;py++){
      for(let px=0;px<piece.shape[py].length;px++){
        if(piece.shape[py][px]){
          const bx=x+px,by=y+py;
          if(bx<0||bx>=COLS||by>=ROWS)return true;
          if(by>=0&&board[by][bx])return true;
        }
      }
    }return false;
  }

  function merge(board,piece,x,y){
    for(let py=0;py<piece.shape.length;py++){
      for(let px=0;px<piece.shape[py].length;px++){
        if(piece.shape[py][px]){
          const bx=x+px,by=y+py;
          if(by>=0&&by<ROWS&&bx>=0&&bx<COLS)
            board[by][bx]=piece.shape[py][px];
        }
      }
    }
  }

  function clearLines(){
    let lines=0;
    outer:for(let y=ROWS-1;y>=0;y--){
      for(let x=0;x<COLS;x++){if(!board[y][x])continue outer;}
      board.splice(y,1);
      board.unshift(Array(COLS).fill(0));
      lines++;y++;
    }
    if(lines>0){
      const points=[0,100,300,500,800];
      score+=points[lines];
      document.getElementById('score').textContent=score;

      if(score > highScore){
        highScore = score;
        localStorage.setItem('tetrisHighScore', highScore);
        document.getElementById('highScore').textContent = highScore;

        const sound = document.getElementById('congratsSound');
        sound.currentTime = 0;
        sound.play().catch(()=>{});

        const highScoreEl = document.getElementById('highScore');
        highScoreEl.style.color = '#ff0';
        highScoreEl.style.fontSize = '22px';
        highScoreEl.style.transition = 'all 0.5s ease';
        highScoreEl.style.textShadow = '0 0 10px #fff, 0 0 20px #ff0';
        setTimeout(() => {
          highScoreEl.style.color = '#eee';
          highScoreEl.style.fontSize = '16px';
          highScoreEl.style.textShadow = 'none';
        }, 1500);
      }

      const newLevel=Math.floor(score/1000)+1;
      if(newLevel!==level){
        level=newLevel;
        document.getElementById('level').textContent=level;
        dropInterval=Math.max(100,1000-(level-1)*100);
        resetDropTimer();
      }
    }
  }

  function rotatePiece(){
    const s=piece.shape,H=s.length,W=s[0].length;
    const r=Array.from({length:W},()=>Array(H).fill(0));
    for(let y=0;y<H;y++){for(let x=0;x<W;x++){r[x][H-1-y]=s[y][x];}}
    const old=piece.shape;
    piece.shape=r;
    for(let i=0;i<3;i++){
      const dx=[0,-1,1][i];
      if(!collide(board,piece,pieceX+dx,pieceY))return;
    }
    piece.shape=old;
  }

  function move(dir){if(!collide(board,piece,pieceX+dir,pieceY))pieceX+=dir;}
  function drop(){
    if(!collide(board,piece,pieceX,pieceY+1))pieceY++;
    else{
      merge(board,piece,pieceX,pieceY);
      clearLines();
      canHold=true;
      spawnPiece();
    }
  }

  function hardDrop(){
    while(!collide(board,piece,pieceX,pieceY+1))pieceY++;
    merge(board,piece,pieceX,pieceY);
    clearLines();canHold=true;spawnPiece();render();
  }

  function spawnPiece(){
    piece=nextPiece||randomPiece();
    nextPiece=randomPiece();
    renderNext();
    pieceX=Math.floor((COLS-piece.shape[0].length)/2);
    pieceY=-piece.shape.length;
    if(collide(board,piece,pieceX,pieceY+1)){
      gameOver=true;
      stopDropTimer();
      if (score > highScore) {
        highScore = score;
        localStorage.setItem('tetrisHighScore', highScore);
        document.getElementById('highScore').textContent = highScore;
        alert('ğŸ‰ ìµœê³ ê¸°ë¡ ê°±ì‹ ! ìƒˆë¡œìš´ ê¸°ë¡: ' + highScore + 'ì !\n\nê²Œì„ ì˜¤ë²„!');
      } else {
        alert('ê²Œì„ ì˜¤ë²„! ì ìˆ˜: ' + score);
      }
    }
  }

  function holdPieceAction(){
    if(!canHold)return;
    if(!holdPiece){
      holdPiece=piece;
      spawnPiece();
    }else{
      const temp=holdPiece;
      holdPiece=piece;
      piece=temp;
      pieceX=Math.floor((COLS-piece.shape[0].length)/2);
      pieceY=-piece.shape.length;
      if(collide(board,piece,pieceX,pieceY+1)){
        gameOver=true;stopDropTimer();alert('ê²Œì„ ì˜¤ë²„! ì ìˆ˜: '+score);
      }
    }
    canHold=false;
    renderHold();
  }

  function drawBlock(x,y,color){
    ctx.fillStyle=color;
    ctx.fillRect(x*BLOCK,y*BLOCK,BLOCK-1,BLOCK-1);
    ctx.strokeStyle='#000';
    ctx.strokeRect(x*BLOCK,y*BLOCK,BLOCK-1,BLOCK-1);
  }

  function render(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    for(let y=0;y<ROWS;y++){
      for(let x=0;x<COLS;x++){
        if(board[y][x])drawBlock(x,y,getColor(board[y][x]));
      }
    }
    if(piece){
      for(let py=0;py<piece.shape.length;py++){
        for(let px=0;px<piece.shape[py].length;px++){
          if(piece.shape[py][px]){
            const bx=pieceX+px,by=pieceY+py;
            if(by>=0)drawBlock(bx,by,piece.color);
          }
        }
      }
    }
    if (isPaused) {
      ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#fff';
      ctx.font = '20px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('PAUSED', canvas.width / 2, canvas.height / 2);
    }
  }

  function renderNext(){
    nctx.clearRect(0,0,nextCanvas.width,nextCanvas.height);
    if(!nextPiece)return;
    const s=nextPiece.shape;const size=20;
    for(let y=0;y<s.length;y++){
      for(let x=0;x<s[y].length;x++){
        if(s[y][x]){
          nctx.fillStyle=nextPiece.color;
          nctx.fillRect(x*size+10,y*size+10,size-2,size-2);
          nctx.strokeStyle='#000';
          nctx.strokeRect(x*size+10,y*size+10,size-2,size-2);
        }
      }
    }
  }

  function renderHold(){
    hctx.clearRect(0,0,holdCanvas.width,holdCanvas.height);
    if(!holdPiece)return;
    const s=holdPiece.shape;const size=20;
    for(let y=0;y<s.length;y++){
      for(let x=0;x<s[y].length;x++){
        if(s[y][x]){
          hctx.fillStyle=holdPiece.color;
          hctx.fillRect(x*size+10,y*size+10,size-2,size-2);
          hctx.strokeStyle='#000';
          hctx.strokeRect(x*size+10,y*size+10,size-2,size-2);
        }
      }
    }
  }

  function getColor(v){
    const map=[null,'#00f0f0','#0000f0','#f0a000','#f0f000','#00f000','#a000f0','#f00000'];
    return map[v]||'#888';
  }

  function resetDropTimer(){
    stopDropTimer();
    dropTimer=setInterval(()=>{if(!gameOver&&!isPaused&&piece){drop();render();}},dropInterval);
  }
  function stopDropTimer(){if(dropTimer)clearInterval(dropTimer);dropTimer=null;}

  function startGame(){
    board=createMatrix(COLS,ROWS);
    score=0;level=1;gameOver=false;isPaused=false;
    holdPiece=null;canHold=true;
    document.getElementById('score').textContent=score;
    document.getElementById('level').textContent=level;
    dropInterval=1000;
    nextPiece=randomPiece();
    renderNext();renderHold();
    spawnPiece();
    resetDropTimer();
    render();

    const bgm = document.getElementById('bgm');
    bgm.volume = 0.5;
    bgm.play().catch(err=>console.log("ë¸Œë¼ìš°ì €ì—ì„œ ìë™ì¬ìƒ ì°¨ë‹¨:",err));
  }

  function togglePause() {
    if (gameOver || !piece) return;
    isPaused = !isPaused;
    const bgm = document.getElementById('bgm');
    if (isPaused) {
      stopDropTimer();
      bgm.pause();
      document.getElementById('pauseBtn').textContent = 'ê³„ì†í•˜ê¸°';
    } else {
      resetDropTimer();
      bgm.play();
      document.getElementById('pauseBtn').textContent = 'ì¼ì‹œì •ì§€';
    }
    render();
  }

  render();
  </script>
</body>
</html>
